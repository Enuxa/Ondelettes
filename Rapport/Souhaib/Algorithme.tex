\newpage

\part{Algorithmes d'encodage et de décodage}

\section{Cadre théorique}

D'un point de vue pratique, les fonctions sont représentées comme des fonctions en escalier, qui de plus sont à support bornés (disons sur $[0, 1]$). C'est-à-dire que l'on manipule des fonctions $f \in L^2(\mathbb{R})$ de la forme $$f = \sum_{j = 0}^{2^{N_0} - 1} a_j \mathbbm{1}_{[2^{-N_0}j, 2^{-N_0}(j+1)[}$$

Le calcul des coefficients s'en retrouve ainsi simplifié :

\begin{align*}
	\langle f, \psi_{n, k} \rangle &= \int_0^1 f(t) \overline{\psi_{n, k}(t)} dt \\
	&= \sum_{j=0}^{N-1} \int_{j}^{j+1} a_j \overline{\psi_{n, k}(t)} dt \\
	&= \sum_{j=0}^{N-1} \int_{j}^{j+1} a_j \overline{\frac{1}{\sqrt{2^n}} \psi(2^n t - k)} dt \\
	&= \sum_{j=0}^{N-1} a_j \frac{1}{\sqrt{2^{3n}}} \int_{2^n j - k}^{2^n(j+1) - k} \overline{\psi(u)} du \quad \text{où $2^nt - k = u$} \\
	&= \sum_{j=0}^{N-1} a_j \frac{1}{\sqrt{2^{3n}}} (F(2^n j - k) - F(2^n (j+1) - k))
\end{align*}

où $F$ est une primitive de $\overline{\psi}$ et $N = 2^{N_0}$.

Étant face à des fonctions en escalier avec un pas fixe, on peut les représenter comme des vecteurs de $\mathbb{R}^N$, où la $(j+1)$-ième coordonnée est la valeur prise sur le $(j+1)$-ième intervalle. On note $\tilde{f} = (a_j, a_1 \cdots a_N)$ et $\DS \widetilde{\psi}_{n, k} = \left(\frac{1}{\sqrt{2^{3n}}} (F(2^n j - k) - F(2^n (j+1) - k))\right)_{j = 0, 1 \cdots N - 1}$, on a alors 

$$\langle f, \psi_{n, k} \rangle =\widetilde{\psi}_{n, k} \transp{\widetilde{f}}$$

De plus, en définissant $S_n = (\langle f, \psi_{n, k}\rangle)_{k = 0, 1 \cdots s(n)}$, avec $s(n)$ le plus grand $k$ que l'on souhaitera calculer, et

$$P_n = 
\left(
	\begin{array}{c}
		\widetilde{\psi}_{n, 0} \\
		\widetilde{\psi}_{n, 1} \\
		\vdots \\
		\widetilde{\psi}_{n, s(n)} 
	\end{array}
\right)$$

on a enfin $$S_n = P_n \transp{\tilde{f} }$$

Chaque $P_n$ est alors le projecteur de $f$ sur l'espace de détails $W_n$, les coefficients sont alors stockés dans le vecteur $S_n$.

\begin{myrem}
	La matrice $\widetilde{f}$ est de taille $1 \times N$, $P_n$ de taille $s(n) \times N$ et $S_n$ de taille $1 \times s(n)$.
\end{myrem}

L'algorithme de compression consiste alors en le remplissage des matrices de projection pour chaque niveau de détail et en la multiplication pour obtenir chaque $S_n$. Nous proposons l'algorithme naïf suivant :

\begin{algorithm}
	\begin{algorithmic}[1]
		\Procedure{Encoder}{$F$, $\widetilde{f}$, $N_0$, $s$}
			\State $P_0 = $ Construire($F$, 0, $s(0)$)
			\For{$n = 1, 2 \cdots N_0$}
				\State $P_n =$ Construire($F$, $n$, s(n))
				\State $S_n = P_n  \transp{\widetilde{f}}$
			    \State $P_{-n} =$ Construire($F$, $-n$)
				\State $S_{-n} = P_{-n} \transp{\widetilde{f}}$
		
			\EndFor
			\State \Return $(S_0, S_{-1}, S_{1} \cdots S_{N_0}, S_{-N_0})$
		\EndProcedure

		\Statex

		\Procedure{Décoder}{$\psi$, $A=(\alpha_{n, k})_{n, k}$, $N_0$, $s(n)$}
		\For{$x = 0, 2^{-1} \cdots 2^{-N_0}$}
		\State $f(x) = 0$
		\For{$n = 0, 1 \cdots N_0$}
		\For{$k = 0, 1 \cdots s(n)$}
		\State $f(x) = f(x) + \alpha_{n, k} \times \psi(2^{-n} x - k)$
		\EndFor
		\EndFor
		\EndFor
		\State \Return $f$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsection{Validation de l'algorithme}

Vérifier que cet algorithme est correct consiste à vérifier que les approximations que l'on a du faire pour passer de valeurs infinies à des valeurs finies pour $n$ et $k$ ne sont pas préjudiciables à la validité des résultats produits. Il s'agit donc de vérifier que les valeurs de $n$ et $k$ enlevées sont négligeables. En effet,  le reste de l'algorithme ne doit pas donner lieu a des erreurs : la formule utilisée est celle qui a été définie plus tôt, et il est certain de terminer. 

% sensibilité
\subsubsection{Coordonnées $n\le 0$}

La valeur de $\langle f,\psi_{n,k}\rangle$ représente à peu près la variation dans l'intervalle $[2^{n}k,2^{n}(k+1)]$.

Étant donné que $f$ est échantillonnée avec une fréquence de $1$, $f$ est constante sur les intervalles $[2^{n}k,2^{n}(k+1)]$ pour $n\le 0$. On néglige donc la valeur des coordonnées à ces indices.
Dans la pratique, cela correspond a des intervalles qui sont plus petits que la fréquence d'échantillonnage: la fonction est donc constante sur l'intervalle, et comme l'ondelette est de moyenne nulle, les valeurs qui lui sont associées sont bien négligeables. 


\subsubsection{Coordonnées $n > \lceil\log_2 N\rceil$}

De même que précédemment, $\langle f,\psi_{n,k}\rangle$ représente la variation dans l'intervalle $[2^{n}k,2^{n}(k+1)]$. Or, cela veut dire que $2^n > 2^{\lceil\log_2 N\rceil}  \geqslant N$,  c'est à dire que les intervalles sont plus grands que le domaine de définition de la fonction. Dès lors, ils ne seront pas utiles.  



\subsubsection{Coordonnées $k$}

On veut obtenir un recouvrement minimal de $[0,N[$ avec les intervalles disjoints $[2^{n}k,2^{n}(k+1)[$ .

Pour que $[2^{n}k,2^{n}(k+1)[\cap[0,N[\neq\emptyset$, il faut que $0\le k< 2^{-n}N$ .

\begin{myexmpl}
	Nous allons décomposer la fonction $f(t)=t$ définie sur $[0, 1]$ dans la base de l'ondelette de Haar, la famille donnée par
	$$\psi_{n, k}(t) = \left\{
	\begin{array}{cc}
		\sqrt{2}^n & 2^{-n}k \leqslant t < 2^{-n} (k+1/2) \\
		-\sqrt{2}^n & 2^{-n}(k+1/2) \leqslant t < 2^{-n} (k+1)
	\end{array}
	\right.$$
	
	Les coefficients sont 
	
	\begin{align*}
		\alpha_{n, k} &= \int_{0}^{1} \psi_{n, k}(t) f(t) dt \\
		&= \sqrt{2^n} \int_{2^{-n}k}^{2^{-n}(k+1/2)} t dt - \sqrt{2^n} \int_{2^{-n}(k+1/2)}^{2^{-n}(k+1)} t dt \\
		&= \sqrt{2^n} \frac{t^2}{2} \bigg \vert_{2^{-n} k}^{2^{-n}(k+1/2)} - \sqrt{2^n} \frac{t^2}{2} \bigg \vert_{2^{-n} (k+1/2)}^{2^{-n}(k+1)} \\
		&= \frac{1}{\sqrt{2}^{3n + 4}}
	\end{align*}
\end{myexmpl}


\section{Version alternative}

Si l'on ne souhaite pas utiliser de coefficients pour des $n$ négatifs, on peut l'éviter en intégrant $\varphi$ dans la décomposition.

En reprenant les calculs de la preuve XXX, on peut aisément retrouver $$\bigcup_{n \in \mathbb{Z}} V_n = V_0 \stackrel{\perp}{\oplus} \left(\bigoplus^{\bot}_{n \in \mathbb{N}} W_n\right)$$

Autrement dit, on peut décomposer tout fonction $f \in L^2(\mathbb{R})$ ainsi : $$f = \sum_{k \in \mathbb{Z}} \langle \varphi_k, f \rangle \varphi_k + \sum_{\substack{k \in \mathbb{Z} \\ n \in \mathbb{N}}} \langle \psi_{n, k}, f \rangle \psi_{n, k}$$



\subsection{Optimisation et compression}

L'intérêt de ce type d'algorithme est de pouvoir compresser les informations pour encoder le signal en perdant le moins d'informations possible. Pour cela, on peut agir à deux niveaux.

\subsubsection{Niveaux de détail}
	Le premier point sur lequel on peut travailler est le niveau de détail. Lorsqu'on observe l'algorithme, on peut voir que les coefficients pour les premières valeurs de $n$ sont moins nombreux, du fait qu'il suffise de quelques ondelettes pour parcourir le domaine de définition. Ce sont ces coefficients qui donnent la structure générale du signal et sont plus impactant que les niveaux de détails suivants. On peut donc penser qu'il est possible d'arrêter l'algorithme plus après moins d'itérations que ce que le l'on a défini précédemment car les détails suivant seront négligeables. 

\subsubsection{Encodage des coefficients}
	Un autre point sur lequel on peut travailler est l'encodage des coefficients, ou tout du moins leur niveau de précision. En effet, il n'est pas forcément utile d'avoir une grande précision sur la valeur du coefficient. De plus, à partir d'un certain rang, comme on l'a pensé précédemment, la plupart des coefficients sont négligeables. Pour optimiser le volume des coefficients formés, il peut être utile de ne stocker que les coefficients non nuls, qui seront bien moins nombreux. 

